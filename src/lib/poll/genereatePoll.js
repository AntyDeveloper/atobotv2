const { OpenAI } = require("openai");
require("dotenv").config();

const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

async function fetchPollQuestionsFromChannel(channelId, client) {
  const channel = await client.channels.fetch(channelId);
  if (!channel || !channel.isTextBased()) return [];

  // Pobierz ostatnie 100 wiadomoÅ›ci (moÅ¼esz zwiÄ™kszyÄ‡ limit jeÅ›li potrzebujesz)
  const messages = await channel.messages.fetch({ limit: 100 });

  // Filtruj tylko te z ankietÄ… i wyciÄ…gnij pytania
  const pollQuestions = [];
  messages.forEach((msg) => {
    if (msg.poll && msg.poll.question && msg.poll.question.text) {
      pollQuestions.push(msg.poll.question.text);
    }
  });

  return pollQuestions;
}

async function generateAndSendMinecraftPoll(
  client,
  multipleChoice = false,
  duration = 86400 // 24 hours in seconds
) {
  const guild = client.guilds.cache.get("1312084655473950821");
  const channel = guild.channels.cache.get("1343437749482553354");

  const pollQuestions = await fetchPollQuestionsFromChannel(
    "1343437749482553354",
    client
  );
  const normalPrompts = [
    `WymyÅ›l kilka (3â€“5) krÃ³tkich i ciekawych ankiet zwiÄ…zanych z Minecraftem (np. wersje gry, moby, style gry, biomy, narzÄ™dzia). NastÄ™pnie wybierz najlepszÄ… z nich i zwrÃ³Ä‡ **tylko jÄ…**. Wszystkie odpowiedzi muszÄ… byÄ‡ logiczne, stylistycznie spÃ³jne i poprawne gramatycznie â€” np. wszystkie w liczbie pojedynczej lub mnogiej. Nie mieszaj jÄ™zykÃ³w (albo wszystko po polsku, albo wszystko po angielsku). KaÅ¼dej opcji przypisz **jedno inne, pasujÄ…ce emoji** i zwrÃ³Ä‡ je osobno w tablicy "emojis", w tej samej kolejnoÅ›ci co opcje. **W pytaniu rÃ³wnieÅ¼ dodaj jedno emoji na poczÄ…tku.** Emoji majÄ… byÄ‡ w osobnym polu â€” nie umieszczaj ich bezpoÅ›rednio w tekÅ›cie pytaÅ„ ani opcji. **ZwrÃ³Ä‡ tylko jednÄ…, wybranÄ… ankietÄ™ w formacie JSON â€” bez Å¼adnych numerÃ³w, komentarzy, wstÄ™pu ani dodatkowego tekstu.** Tekst pytania i kaÅ¼dej odpowiedzi nie moÅ¼e byÄ‡ dÅ‚uÅ¼szy niÅ¼ 55 znakÃ³w. Format:
  {
    "question": "ğŸ§± Twoje pytanie",
    "options": ["Opcja A", "Opcja B", "Opcja C"],
    "emojis": ["ğŸŒ²", "ğŸ”¥", "ğŸ§±"]
  }
  Dozwolone tylko 2 lub 3 opcje. PamiÄ™taj, Å¼e te pytania juÅ¼ byÅ‚y zadawane: ` +
      pollQuestions.join(", "),
  ];

  const brainrotPrompts = [
    `WymyÅ›l kilka (3â€“5) absurdalnych i Å›miesznych ankiet z luÅºnym powiÄ…zaniem do Minecrafta lub TikTokowego klimatu brainrot (np. krokodilo bombardiro, sigma villager, Herobrine robiÄ…cy latte). NastÄ™pnie wybierz najlepszÄ… z nich i zwrÃ³Ä‡ **tylko jÄ…**, w formacie JSON. KaÅ¼da opcja powinna mieÄ‡ jedno **inne, pasujÄ…ce lub odjechane emoji**, przypisane osobno w tablicy "emojis", w tej samej kolejnoÅ›ci co odpowiedzi. **W pytaniu teÅ¼ dodaj jedno emoji na poczÄ…tku.** Nie powtarzaj emoji. **Nie dodawaj emoji bezpoÅ›rednio do tekstu opcji ani pytania.** Tekst pytania i kaÅ¼dej odpowiedzi nie moÅ¼e przekraczaÄ‡ 55 znakÃ³w. **ZwrÃ³Ä‡ tylko jednÄ… wybranÄ… ankietÄ™ â€” jako czysty JSON bez Å¼adnych dodatkowych numerÃ³w, opisÃ³w ani komentarzy.** Format:
  {
    "question": "ğŸ§Œ Åšmieszne pytanie",
    "options": ["Odp A", "Odp B", "Odp C"],
    "emojis": ["ğŸ§Œ", "ğŸ›¸", "ğŸ"]
  }`,
  ];
  const useBrainrot = Math.random() < 0.2;
  const prompt = (useBrainrot ? brainrotPrompts : normalPrompts)[0];

  const response = await openai.chat.completions.create({
    model: "gpt-4",
    messages: [{ role: "user", content: prompt }],
    max_tokens: 150,
    temperature: 1.2,
  });

  console.log(response.choices[0].message?.content || "Brak odpowiedzi");
  let poll;
  try {
    // Pobierz content bezpiecznie
    const content = response.choices[0].message?.content || "";
    if (!content) {
      console.error("âŒ Brak contentu w odpowiedzi OpenAI!");
      return;
    }
    const jsonMatch = content.match(
      /```json\s*([\s\S]*?)```|([\[\{][\s\S]*[\]\}])/i
    );
    const jsonString = jsonMatch ? jsonMatch[1] || jsonMatch[2] : content;
    let parsed = JSON.parse(jsonString);
    // JeÅ›li to tablica, weÅº pierwszy element
    poll = Array.isArray(parsed) ? parsed[0] : parsed;
  } catch (err) {
    console.error("âŒ BÅ‚Ä…d parsowania JSON-a:", err);
    return;
  }
  // ...existing code...
  const { question, options, emojis } = poll;
  if (
    !question ||
    !options ||
    options.length < 2 ||
    !emojis ||
    !Array.isArray(emojis) ||
    emojis.length !== options.length
  ) {
    console.warn("âš ï¸ Niepoprawny format ankiety");
    return;
  }

  // PoÅ‚Ä…cz opcje z emoji z tablicy emojis
  const answers = options.slice(0, 3).map((option, idx) => ({
    text: option.trim(),
    emoji: emojis[idx],
  }));

  await channel.send({
    poll: {
      question: { text: question },
      allowMultiSelect: multipleChoice,
      expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000),
      answers,
    },
  });

  // await channel.send({ content: "<@&1343415863423930390>" }).then((message) => {
  //   setTimeout(
  //     () => message.delete().catch((err) => console.log(err)),
  //     2 * 1000
  //   );
  // });
}

module.exports = generateAndSendMinecraftPoll;
